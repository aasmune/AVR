
PWM.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000001fa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000186  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800100  00800100  000001fa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000001fa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000022c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000020  00000000  00000000  0000026c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000000b2  00000000  00000000  0000028c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000064  00000000  00000000  0000033e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000000b7  00000000  00000000  000003a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000024  00000000  00000000  0000045c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000014f  00000000  00000000  00000480  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000010  00000000  00000000  000005cf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 66 00 	jmp	0xcc	; 0xcc <__ctors_end>
   4:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
   8:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
   c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  10:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  14:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  18:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  1c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  20:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  24:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  28:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  2c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  30:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  34:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  38:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  3c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  40:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  44:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  48:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  4c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  50:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  54:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  58:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  5c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  60:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  64:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  68:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  6c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  70:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  74:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  78:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  7c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  80:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  84:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  88:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  8c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  90:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  94:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  98:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  9c:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  a0:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  a4:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  a8:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  ac:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  b0:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  b4:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  b8:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  bc:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  c0:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  c4:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>
  c8:	0c 94 78 00 	jmp	0xf0	; 0xf0 <__bad_interrupt>

000000cc <__ctors_end>:
  cc:	11 24       	eor	r1, r1
  ce:	1f be       	out	0x3f, r1	; 63
  d0:	cf ef       	ldi	r28, 0xFF	; 255
  d2:	d8 e0       	ldi	r29, 0x08	; 8
  d4:	de bf       	out	0x3e, r29	; 62
  d6:	cd bf       	out	0x3d, r28	; 61

000000d8 <__do_clear_bss>:
  d8:	21 e0       	ldi	r18, 0x01	; 1
  da:	a0 e0       	ldi	r26, 0x00	; 0
  dc:	b1 e0       	ldi	r27, 0x01	; 1
  de:	01 c0       	rjmp	.+2      	; 0xe2 <.do_clear_bss_start>

000000e0 <.do_clear_bss_loop>:
  e0:	1d 92       	st	X+, r1

000000e2 <.do_clear_bss_start>:
  e2:	a2 30       	cpi	r26, 0x02	; 2
  e4:	b2 07       	cpc	r27, r18
  e6:	e1 f7       	brne	.-8      	; 0xe0 <.do_clear_bss_loop>
  e8:	0e 94 7a 00 	call	0xf4	; 0xf4 <main>
  ec:	0c 94 c1 00 	jmp	0x182	; 0x182 <_exit>

000000f0 <__bad_interrupt>:
  f0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f4 <main>:
bool SW1_pressed,SW2_pressed;

int main(void)
{	
	//sett opp LED pins som utgang
	DDRD |= (1<<LED1)|(1<<LED2);
  f4:	8a b1       	in	r24, 0x0a	; 10
  f6:	80 63       	ori	r24, 0x30	; 48
  f8:	8a b9       	out	0x0a, r24	; 10
	//DDRA |= (1<<LED3);

	PORTD |=(1<<LED1) | (1<<LED2);
  fa:	8b b1       	in	r24, 0x0b	; 11
  fc:	80 63       	ori	r24, 0x30	; 48
  fe:	8b b9       	out	0x0b, r24	; 11
	
	//husk pullups for knappene
	PORTC |= (1<<SW1);
 100:	41 9a       	sbi	0x08, 1	; 8
	PORTA |= (1<<SW2);//|(1<<SW3);
 102:	10 9a       	sbi	0x02, 0	; 2

	/*	Set the timer/counter for 8 bit fast pwm (se i databladet etter timer/counter control register A, kap 18.11)
		Det er en av de måtene vi kan bruke timers på for å gjøre det vi trenger i oppgaven */

		TCCR1B |= (1<<WGM2);
 104:	e1 e8       	ldi	r30, 0x81	; 129
 106:	f0 e0       	ldi	r31, 0x00	; 0
 108:	80 81       	ld	r24, Z
 10a:	88 60       	ori	r24, 0x08	; 8
 10c:	80 83       	st	Z, r24
		TCCR1A |= (1<< WGM0);
 10e:	a0 e8       	ldi	r26, 0x80	; 128
 110:	b0 e0       	ldi	r27, 0x00	; 0
 112:	8c 91       	ld	r24, X
 114:	81 60       	ori	r24, 0x01	; 1
 116:	8c 93       	st	X, r24
	/* Set OC1A og OC1B pins on compare match, clear at bottom
		Dette er en inverterende mode pga leds er koblet som active low. 
		Da er lysutgangen proporsjonelt med verdien som ligger i output compare register
		*/

		TCCR1A |= (1<<COMA1) | (1<<COMA0) | (1<<COMB0) | (1<<COMB1);
 118:	8c 91       	ld	r24, X
 11a:	80 6f       	ori	r24, 0xF0	; 240
 11c:	8c 93       	st	X, r24
	/*	velg clock source til prescaler og sette den til en fornuftig verdi 
		(her er vi ikke interesert i perioden paa timeren, bare duty cycle til PWM)
		Denne operasjonen starter timeren.*/


	TCCR1B |= (1<<CS0);
 11e:	80 81       	ld	r24, Z
 120:	81 60       	ori	r24, 0x01	; 1
 122:	80 83       	st	Z, r24
	/*	output compare registerene bestemmer PWM duty cycle når timeren er i 8bit Fast PWM.
		prøv å leke med verdiene i registrene for å se hvordan PWM og lysstyrken blir påvirket*/
	OCRAL = 0x00;	//fadeLevel;
 124:	10 92 88 00 	sts	0x0088, r1
	OCRBL = 0xff;
 128:	8f ef       	ldi	r24, 0xFF	; 255
 12a:	80 93 8a 00 	sts	0x008A, r24

			if (!((1<<SW1) & PINC))
			{
				if (!SW1_pressed)
				{
					OCRAL = (OCRAL <<1) + 1;
 12e:	a8 e8       	ldi	r26, 0x88	; 136
 130:	b0 e0       	ldi	r27, 0x00	; 0
					OCRBL >>=1;
 132:	ea e8       	ldi	r30, 0x8A	; 138
 134:	f0 e0       	ldi	r31, 0x00	; 0
					SW1_pressed = true;
 136:	91 e0       	ldi	r25, 0x01	; 1
    while (1) 
    {
		/*	Nå skal dere få det til at hvis man trykker på SW0,minske lysstyrken til LED1 mens lysstyrken til LED2 øker
			Og akkurat motsatt for SW1 */

			if (!((1<<SW1) & PINC))
 138:	31 99       	sbic	0x06, 1	; 6
 13a:	0e c0       	rjmp	.+28     	; 0x158 <main+0x64>
			{
				if (!SW1_pressed)
 13c:	80 91 00 01 	lds	r24, 0x0100
 140:	81 11       	cpse	r24, r1
 142:	0c c0       	rjmp	.+24     	; 0x15c <main+0x68>
				{
					OCRAL = (OCRAL <<1) + 1;
 144:	8c 91       	ld	r24, X
 146:	88 0f       	add	r24, r24
 148:	8f 5f       	subi	r24, 0xFF	; 255
 14a:	8c 93       	st	X, r24
					OCRBL >>=1;
 14c:	80 81       	ld	r24, Z
 14e:	86 95       	lsr	r24
 150:	80 83       	st	Z, r24
					SW1_pressed = true;
 152:	90 93 00 01 	sts	0x0100, r25
 156:	02 c0       	rjmp	.+4      	; 0x15c <main+0x68>
				}
			}
			else
			{

			SW1_pressed = false;
 158:	10 92 00 01 	sts	0x0100, r1
			}

			if (!((1<<SW2) & PINA))
 15c:	00 99       	sbic	0x00, 0	; 0
 15e:	0e c0       	rjmp	.+28     	; 0x17c <main+0x88>
			{
				if (!SW2_pressed)
 160:	80 91 01 01 	lds	r24, 0x0101
 164:	81 11       	cpse	r24, r1
 166:	e8 cf       	rjmp	.-48     	; 0x138 <main+0x44>
				{
					OCRBL = (OCRBL <<1) + 1;
 168:	80 81       	ld	r24, Z
 16a:	88 0f       	add	r24, r24
 16c:	8f 5f       	subi	r24, 0xFF	; 255
 16e:	80 83       	st	Z, r24
					OCRAL >>=1;
 170:	8c 91       	ld	r24, X
 172:	86 95       	lsr	r24
 174:	8c 93       	st	X, r24
					SW2_pressed = true;
 176:	90 93 01 01 	sts	0x0101, r25
 17a:	de cf       	rjmp	.-68     	; 0x138 <main+0x44>
				}
			}
			else
			{

			SW2_pressed = false;
 17c:	10 92 01 01 	sts	0x0101, r1
 180:	db cf       	rjmp	.-74     	; 0x138 <main+0x44>

00000182 <_exit>:
 182:	f8 94       	cli

00000184 <__stop_program>:
 184:	ff cf       	rjmp	.-2      	; 0x184 <__stop_program>
